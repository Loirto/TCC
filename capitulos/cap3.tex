\chapter{O vírus polimórfico}

Na época do MS-DOS os vírus eram simples e divididos em categorias básicas: infectadores do setor de boot (boot sector\footnote{http://en.wikipedia.org/w/index.php?title=Boot\_sector\&oldid=524626394}), infectadores de arquivos .COM e infectadores de arquivos .EXE. Nesta época a vida também era relativamente fácil para os fabricantes de antivírus pois os vírus eram em menor número e a detecção era baseada em assinatura do código malicioso\footnote{A assinatura de um vírus é um padrão de bytes que identifica unicamente aquele vírus}. As atualizações dos antivírus eram em geral atualização da base de dados que continham as assinaturas, o tamanho e a forma de correção da infecção.

Um exemplo desta época é o vírus de boot sector Stoned\footnote{http://en.wikipedia.org/w/index.php?title=Stoned\_\%28computer\_virus\%29\&oldid=532807447} que infectou muitos computadores no final da década de 1980. A assinatura mais óbvia para este vírus seria \textbf{Your PC is now Stoned!} que o vírus exibia quando o computador estava inicializando. Portanto, um anti-virus da época precisaria apenas buscar esta string no registro de boot sector do disco rígido e dos disquetes que estivessem na unidade e, caso encontrasse, eliminar o vírus da memória - pois ele ficava residente infectando todo disquete que fosse colocado no computador - e em seguida substituir o boot sector pelo original que o vírus mantinha em outra localização do disco.

Algumas versões de vírus de boot sector eram um pouco mais inteligentes e assumiam controle da função de leitura de disco do BIOS. Assim, ao detectar que algum software estava tentando ler o boot sector, ele carregava a cópia original fazendo com que o antivírus não suspeitasse da existência da infecção. Logo, os desenvolvedores de antivírus perceberam esta manobra e começaram a vasculhar a memória RAM do computador em busca de assinaturas de vírus e não mais somente em disco.

Também começaram a surgir cada vez mais vírus e a detecção por assinatura somente não estava mais dando certo pois novas variações do mesmo vírus tinham assinaturas diferentes. Por exemplo, o Stoned mencionado anteriormente teve muitas variações e buscar pela assinatura original não detectava mais o vírus pois a mensagem foi modificada. Então as empresas de antivírus começaram a desenvolver algorítmos que analisavam o código a fim de detectar certos padrões de execução (chamado código malicioso) que identificavam por certo um código que não deveria ser executado, utilizando análise heurística\footnote{http://en.wikipedia.org/w/index.php?title=Heuristic\_analysis\&oldid=529072201} \footnote{http://forums.avg.com/pt-pt/avg-forums?sec=thread\&act=show\&id=371}.

Então, os desenvolvedores de vírus perceberam que para evitar a detecção deveriam modificar a aparência do código, surgindo assim os vírus polimórficos. A criação de vírus polimórficos iniciou-se em meados dos anos 1990, com a criação do vírus chamado \textbf{1260}\footnote{http://en.wikipedia.org/w/index.php?title=1260\_\%28computer\_virus\%29\&oldid=527495020}. Também nesta época, um desenvolvedor de vírus búlgaro, chamado Dark Avenger\footnote{http://en.wikipedia.org/w/index.php?title=Dark\_Avenger\&oldid=513782286} criou um módulo objeto que ele chamou de \textit{Mutation engine}. Este código foi desenhado para ser ligado ao vírus durante a compilação e ser chamado pelo vírus durante o processo de replicação para dar ao vírus a capacidade de mutação a cada nova infecção. Foi uma grande revolução na forma de pensar e construir vírus e um enorme desafio para a indústria de antivírus. 

\section{As partes do vírus polimórfico}
Basicamente, um virus polimórfico pode ser dividido em duas partes: o código do vírus propriamente dito e a rotina de descriptografia. O corpo do vírus é criptografado e a cada nova infecção uma nova criptografia é feita, desta forma tornando as variações impossíveis de detectar através de casamento de padrões.

A rotina de descriptografia é responsável por restaurar o código original do vírus e passar o controle de execução a ele. Esta rotina tem que ser gerada pelo gerador do código polimórfico de tal maneira que não seja um código estático pois senão seria facilmente detectável pelos antivírus usando busca por padrões e todo o trabalho da criptografia para esconder o código do vírus seria inútil.

\section{Protegendo a rotina de descriptografia}
Conforme vimos, as técnicas de criptografia são eficientes para proteger o código polimórfico mas possuem um calcanhar de Aquiles: a rotina de descriptografia. Como o antivírus não poderia detectar o codigo do vírus, uma vez que ele está criptografado, então a única possibilidade de detectar o vírus é através da rotina de descriptografia. Esta é uma grande vantagem, pois o criador do vírus tem certeza de que o código malicioso está protegido pela criptografia e portanto não será detectado, mas também é um grande problema pois o código da descriptografia fica exposto e, em geral, é um código pequeno o que o torna difícil de ser camuflado. Existem várias técnicas usadas para proteger esta rotina contra algoritmos de heurística, casamento de padrões e mesmo engenharia reversa. Vamos ver algumas delas.

\subsection{Técnicas anti-antivírus}
As técnicas anti-antivírus tem a finalidade de impedir a detecção do código malicioso. Algumas destas técnicas, devido ao avanço dos antivírus, não funcionam mais, no entanto foram largamente utilizadas no passado e por isso são descritas nesta seção.
\subsubsection{Retrovírus}
Na natureza, um retrovírus ataca o sistema imunológico. Por este motivo, um vírus que tenta desativar o antivírus que está sendo executado no computador, é chamado de retrovírus. Em geral, a primeira ação do retrovírus, após estar em execução, é listar todos os processos que estão sendo executados no computador, buscando pelos processos que ele reconhece como antivírus e matando-os em seguida. O vírus pode também buscar além de antivírus outros processos de segurança, como firewall e anti-spyware. Algumas vezes o retrovírus pode passar-se por um componente do próprio antivírus e tentar fazer com que o usuário desinstale a proteção\footnote{http://www.symantec.com/connect/blogs/rogue-turning-retrovirus}, mostrando uma mensagem, por exemplo, de que o sistema precisa ser atualizado e que o anti-virus precisa ser desinstalado e/ou desativado momentaneamente. Algumas vezes ainda, após a desinstalação, ele instala um falso antivírus para evitar que o usuário volte a instalar novamente a sua proteção.

Um retrovírus não precisa necessariamente matar o processo do antivírus ou desinstalá-lo, ele pode simplesmente modificar a prioridade do processo, tornando-a tão baixa que o antivírus poderá nem sequer ser executado.

\subsubsection{Ocultação do ponto de entrada}
Todo executável tem um ponto de entrada. Este ponto de entrada, é onde o código começa a ser executado. O ponto de entrada de um executável é marcado no cabeçalho do arquivo e está descrito no apêndice \ref{ap:A}. Em C, isso corresponderia à função main(). Os primeiros vírus adicionavam o código malicioso ao final do arquivo e mudavam o ponto de entrada no cabeçalho do executável para apontar para o vírus. Outros, adicionavam uma instrução para saltar para o início do código do vírus, sem mudar o cabeçalho do executável. Em qualquer destes casos, o trabalho do antivírus era muito facilitado pois só precisava analisar o início do código do ponto de entrada do executável para determinar se existia ali um vírus conhecido. 

Vírus modernos não mudam mais o ponto de entrada no cabeçalho do executável, nem inserem salto no código original. O vírus \textbf{Simile}\footnote{http://www.symantec.com/connect/articles/analysis-simile} é um caso muito interessante. Além de usar um mecanismo polimórfico muito difícil de ser detectado, chamado Tuareg\footnote{http://www.peterszor.com/drill.pdf} ele infecta tanto executáveis do Windows quanto executáveis do Linux. Diferente da abordagem padrão, a execução deste vírus não é durante a inicialização do executável. Ele só será executado quando o programa principal terminar. No windows, ele busca na seção IMPORT do PE a função de API \textbf{ExitProcess} ou \textbf{\_exit}. Se não encontrar, o arquivo não é infectado. Se encontrar, ele muda a chamada à API para chamar diretamente o codigo do vírus. No Linux, ele substitui as chamadas à função \textbf{exit}, fazendo com que apontem para o código de inicialização do vírus. Portanto, somente quando o programa terminar é que o vírus será executado.

Técnicas semelhantes podem ser usadas para qualquer API do sistema.

\subsubsection{Anti-emulação}
Antivírus modernos executam o código de programas desconhecidos em uma máquina virtual, ou emulador de execução, chamada SandBox a fim de detectar ações suspeitas de vírus. Em geral, este processo é executado apenas na primeira vez que o usuário for usar o novo programa. Logo, os criadores de vírus criaram técnicas para burlar este processo de emulação.

Uma idéia básica é que o antivírus não pode emular todo o código do executável pois se assim o fizer, irá tomar um tempo inaceitável pelo usuário. Então, o criador do vírus só precisa ter certeza de que terá código suficiente para ser emulado e que pareça legítimo a fim de burlar o emulador.

Outra abordagem seria não executar o vírus todas as vezes, mas sim de forma aleatória. Assim as chances de que o emulador não detecte o vírus são ampliadas pois o código emulado pareceria inofensivo. Digamos, por exemplo, que um vírus executasse somente nas sextas-feiras. Assim, somente seria detectado pelo emulador se a  primeira execução do usuário tivesse sido numa sexta-feira. Também poderia usar um contador: a cada 100 execuções, uma dispara o vírus.

Em geral, emulador assume que o código malicioso está próximo do Entry Point, conforme discutimos no item anterior, portanto, técnicas de ocultação do ponto de entrada ainda são válidas com alguns emuladores.

Vírus mais sofisticados conseguem detectar quando estão sendo executados em um emulador e não executam nenhum código anormal neste caso. Simplesmente devolvem a execução para o código legítimo da aplicação.

\subsection{Técnicas anti-debugging} 
\footnote{pferrie.host22.com/papers/antidebug.pdf}
\footnote{http://en.wikipedia.org/w/index.php?title=Debugging\&oldid=533173326} 
\footnote{http://thelegendofrandom.com/blog/archives/2100} 
\footnote{http://www.symantec.com/connect/articles/windows-anti-debug-reference}
\footnote{web.eecs.umich.edu/~mibailey/publications/dsn08\_final.pdf} 
\footnote{research.dissect.pe/docs/blackhat2012-paper.pdf}
\footnote{Software: http://newgre.net/idastealth}
\footnote{Análise vírus Invir http://www.peterszor.com/invirs.pdf}
Quando um anti-virus não consegue reconhecer o vírus, uma amostra do arquivo infectado é enviado para análise por técnicos da empresa de antivírus, que usarão técnicas de engenharia reversa para analisar o funcionamento do código malicioso. Assim que conseguirem entender o funcionamento do vírus, uma nova vacina é criada. Portanto, é de grande importância para o desenvolvedor do código malicioso que este processo seja dificultado ao máximo, prorrogando assim o tempo de vida útil do vírus, worm, malware ou spyware. 

A engenharia reversa é largamente utilizada todos os dias, com propósitos nobres e outros não tão nobres assim:
\begin{itemize}
 \item Entender como funciona um algorítmo que teve o fonte perdido ou cujo fornecedor não existe mais.
 \item Estudar o código de um driver proprietário que não disponibiliza os fontes e que está com defeito ou que não existe versão para o SO desejado. 
 \item Estudar um código malicioso a fim de criar uma defesa contra o mesmo.
 \item Estudar um algorítmo para criar uma outra versão e obter lucro vendendo sua própria solução.
\end{itemize}

Muitas empresas querem proteger seu patrimônio intelectual e empregam, além de criptografia, técnicas para impedir ou dificultar muito a engenharia reversa em seus produtos. A seguir vamos descrever brevemente algumas das técnicas utilizadas, tendo em mente que várias delas não funcionam nos dias atuais mas vamos escrever sobre elas pois foram muito utilizadas pelos desenvolvedores de vírus. 

\subsubsection{Breakpoint e Single-step}
Um software de depuração tem por princípio pode executar o código linha a linha (ou de instrução em instrução assembler) ou passo-a-passo (single step) e ter pontos de parada pré-determinados (breakpoint) onde a execução será pausada para que o programador possa analisar o código/pilha/flags/variáveis. 



\section{Polimorfismo em linguagens interpretadas}

%\glossario{virus}{teste de descrição do glossário}
Vírus de computador podem ser escritos em qualquer linguagem. Alguns vírus são escritos para infectar o próprio código fonte dos programas, antes mesmo deles serem compilados, fazendo assim com que o código malicioso faça parte do código do software legítimo. Este tipo de vírus é bem raro pois é muito difícil analisar o código fonte de um software para saber exatamente onde colocar o código malicioso minimizando as chances de ser facilmente detectado. Um exemplo deste vírus é o \textbf{Induc}\footnote{http://www.symantec.com/connect/blogs/interesting-case-induc-virus}. Surgido em 2009, este vírus tem uma ação bem interessante: caso no computador exista o ambiente de desenvolvimento (IDE) da linguagem Delphi\textsuperscript{\textregistered} nas versões de 4 a 7, o vírus modifica a biblioteca básica da linguagem fazendo com que todo e qualquer software que seja produzido neste ambiente tenha uma cópia do vírus. No entanto, o vírus em sí não causa nenhum dano, apenas se propaga para todo o sofware gerado na máquina contendo o Delphi. Apesar do Induc não fazer nenhum mal, a idéia em sí pode ser usada para qualquer fim malicioso. Tanto que em 2011 surgiram duas variações do Induc, chamadas \textbf{Induc.B} e \textbf{Induc.C}\footnote{http://blog.eset.com/2011/09/14/the-induc-virus-is-back}. Estas variações são maliciosas e usam técnicas anti-debugging e polimorfismo para ocultar seu código.

No âmbito das linguagens interpretadas, os vírus de macro em Visual Basic for Applications (VBA) que infectavam documentos dos aplicativos do Office da Microsoft, são o exemplo clássico. Talvez um dos vírus mais famosos deste universo tenha sido o Melissa\footnote{http://en.wikipedia.org/w/index.php?title=Melissa\_(computer\_virus)\&oldid=537815781}. O Melissa infectava arquivos do MS-Word e usava o Outlook para enviar e-mail para todos os contatos da vítima com o fim de propagação. Em 1999 ele chegou a derrubar alguns servidores da internet porque gerou um congestionamento no sistema de e-mail. Existem muito poucos vírus polimórficos em macro. Uma análise mais detalhada deste tipo de vírus pode ser encontrada em \footnote{http://www.symantec.com/connect/articles/polymorphic-macro-viruses-part-one} e \footnote{http://www.symantec.com/connect/articles/polymorphic-macro-viruses-part-two} ou em forma de artigo em \footnote{http://craigchamberlain.com/library/malware/Polymorphic\%20Macro\%20Viruses.pdf}. Ainda dentro dos códigos interpretados, devemos citar que até mesmo os arquivos .BAT do DOS/Windows podem ser usados como vírus. Um exemplo disso é o worm Mumu\footnote{http://en.wikipedia.org/w/index.php?title=Mumu\_(computer\_worm)\&oldid=314377507}. Não vamos usar estes exemplos pois já existe muita literatura a respeito deste assunto. 

Existem vírus desenvolvidos para linguagens interpretadas, como Python e Ruby e até mesmo JavaScript. Vamos usar a linguagem Ruby como exemplo para desenvolver um código bem simples para demonstrar a capacidade de polimorfismo desta linguagem. O que torna possível a execução do código do polimórfico é o comando EVAL() do Ruby. 
